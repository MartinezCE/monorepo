import createHttpError from 'http-errors';
import { FindOptions, NonNullFindOptions, Op, Transaction } from 'sequelize';
import { BLUEPRINT_ACTIVE_RESERVATIONS } from '../config/errorCodes';
import Blueprint, { BlueprintAttributes, BlueprintStatus } from '../db/models/Blueprint';
import Company from '../db/models/Company';
import Floor from '../db/models/Floor';
import Location from '../db/models/Location';
import User from '../db/models/User';
import WPMReservation from '../db/models/WPMReservation';
import { BlueprintDTO } from '../dto/blueprint';

export default class BlueprintService {
  static async destroyNotInByUser(
    blueprints: BlueprintDTO[],
    userId: number,
    locationId: number,
    transaction?: Transaction
  ) {
    const blueprintsToDelete = await Blueprint.scope([
      { method: ['byUser', userId] },
      { method: ['byLocation', locationId] },
    ]).findAll({
      where: {
        id: {
          [Op.notIn]: blueprints.map(b => b.id || -1),
        },
      },
      attributes: ['id'],
      transaction,
    });

    return Blueprint.destroy({
      where: {
        id: blueprintsToDelete.map(b => b.id),
      },
      transaction,
    });
  }

  static async bulkUpsert(blueprints: BlueprintDTO[], transaction?: Transaction) {
    const updateOnDuplicate: Exclude<keyof BlueprintAttributes, 'id' | 'floorId'>[] = ['name', 'status', 'url'];
    return Blueprint.bulkCreate(blueprints, { updateOnDuplicate, transaction });
  }

  static async removeByUser(userId: number, id: string, transaction?: Transaction) {
    const blueprint = await Blueprint.scope([
      { method: ['byUser', userId] },
      { method: ['withReservations', false, { [Op.gte]: new Date() }] },
    ]).findOne({
      where: { id },
      rejectOnEmpty: true,
      transaction,
    });

    if (blueprint.seats.some(s => s.WPMReservations.length)) throw createHttpError(400, BLUEPRINT_ACTIVE_RESERVATIONS);

    return blueprint.destroy({ transaction });
  }

  static async getOneByUser(userId: number, id: number, options?: NonNullFindOptions<Blueprint>) {
    return Blueprint.scope([{ method: ['byUser', userId] }]).findOne({
      where: {
        id,
      },
      rejectOnEmpty: true,
      ...options,
    });
  }

  static async getAllByCompany(companyId: number, status?: BlueprintStatus, options?: FindOptions<Blueprint>) {
    return Blueprint.scope([{ method: ['byCompany', companyId] }]).findAll({
      include: {
        model: Floor,
        attributes: ['number'],
        required: true,
        include: [
          {
            model: Location,
            attributes: ['name'],
            required: true,
            include: [
              {
                model: Company,
                attributes: [],
                required: true,
                where: { id: companyId },
              },
            ],
          },
        ],
      },
      where: status ? { status } : {},
      ...options,
    });
  }

  static async getOneAssociatedToUser(userId: number, id: number, options?: FindOptions<Blueprint>) {
    return Blueprint.findOne({
      where: { id },
      include: {
        required: true,
        model: User,
        through: {
          where: { userId },
        },
      },
      rejectOnEmpty: true,
      ...options,
    });
  }

  static async hasSeats(id: number, seatsIds: number[]) {
    const blueprint = await Blueprint.findByPk(id, { rejectOnEmpty: true });
    return blueprint.hasSeats(seatsIds);
  }

  static async getReservationsUsers(
    blueprintId: number,
    companyId: number,
    originTz?: string,
    destinationTz?: string,
    selectedDate?: Date
  ) {
    return User.findAll({
      include: {
        model: WPMReservation.scope([
          { method: ['byCompany', companyId] },
          { method: ['byBlueprint', blueprintId] },
          { method: ['byDate', selectedDate, originTz, destinationTz] },
        ]),
      },
      attributes: { exclude: ['password'] },
    });
  }

  static async findOneByLocation(
    companyId: number, // TODO: Add companyId scope
    locationId: number,
    options?: Omit<NonNullFindOptions<BlueprintAttributes>, 'where'>
  ) {
    return Blueprint.scope({ method: ['byLocation', locationId] }).findOne(options);
  }

  static async findOrCreateByFloor(companyId: number, locationId: number, floorId: number, transaction?: Transaction) {
    let blueprint = await BlueprintService.findOneByLocation(companyId, locationId, {
      transaction,
      rejectOnEmpty: false,
    });
    if (!blueprint) {
      [blueprint] = await BlueprintService.bulkUpsert(
        [{ floorId, name: `Autogenerated-${new Date().toUTCString()}`, status: BlueprintStatus.PUBLISHED }],
        transaction
      );
    }

    return blueprint;
  }

  static async findOrCreateAssociatedToFloor(locationId: number, floorId: number) {
    let blueprint = await Blueprint.scope({ method: ['byLocation', locationId] }).findOne({
      where: { floorId },
      rejectOnEmpty: false,
    });
    if (!blueprint) {
      [blueprint] = await BlueprintService.bulkUpsert([
        { floorId, name: `Autogenerated-${new Date().toUTCString()}`, status: BlueprintStatus.PUBLISHED },
      ]);
    }
    return blueprint;
  }

  static async getBlueprintBySeatId(seatId: number, transaction?: Transaction) {
    return Blueprint.scope([{ method: ['bySeat', seatId] }]).findOne({ transaction });
  }

  static async setUsers(blueprintId: number, users: User[]) {
    const blueprint = await Blueprint.findByPk(blueprintId);
    return blueprint.setUsers(users.map(u => u.id));
  }

  static async getUsers(blueprintId: number) {
    const blueprint = await Blueprint.findByPk(blueprintId, {
      include: [
        {
          model: User,
        },
      ],
    });
    return blueprint;
  }

  static async removeUser(blueprintId: number, userId: number) {
    const blueprint = await Blueprint.findByPk(blueprintId);
    return blueprint.removeUser(userId);
  }
}
